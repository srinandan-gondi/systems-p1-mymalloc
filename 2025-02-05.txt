CS 214 / More types
===================


enum
----

enum bool { false, true };
    declares a type "enum bool"
    declares two "enumerators", false and true
    
    -> enums are actually just integers, and the enumerators are
        specific constants
        by default, numbered sequentially starting from zero


enum direction { north, south, east, west };


switch (move_direction) {
    case north: ...
    case south: ...
    case east: ...
    case west: ...
}

enums are handy for writing more readable code

but, because these are integers, the compiler will automatically
cast between enums and ints as needed


    enum direction d = 4;
            // invalid, but the compiler won't warn us
    
    
    int x = east;
            // nonsense, but the compiler will allow it

    enum bool b = south;
            // nonsense, but the compiler will allow it



for (enum direction d = north; d <= west; d++) {
    // allowed
    // this is a loop through all possible directions
    // (note: if we add more directions later, we will have to change
    // all loops like this)
}


struct
------

bundle multiple data items into a single object

struct point {
    double x;   // field declaration
    double y;
};

struct rectangle {
    struct point topleft;
    struct point bottomright;
    enum color background;
    char *name;
};


struct polygon {
    enum color fill;
    struct point *vertices;
    int num_vertices;
};


struct point p;
    // p directly refers to a point
    
struct point *q;
    // q indirectly refers to a point (or NULL)
    
q = &p;

p.x   <- field access

p.x = p.x + 1;

    note: * has lower precedence than .
    

(*q).x      // dereference q and obtain field x


        in general *a.b means *(a.b)


shorthand:
    instead of (*q).x, we can write q->x
    

unlike arrays, struct variables do not decay to pointers

struct p a = { 0, 2.6 };   // struct initialization
struct p b;

b = a;   // equivalent to b.x = a.x; b.y = a.y;


additionally, structs are passed by value to functions

void foo(struct point p)
{
    p.x = 0;  // pointless, because it only affects a local copy of
                // its argument
}

foo(a); // would not change a.x


however, we usually don't pass structs directly to functions

void bar(struct point *p)
{
    p->x = 0;
}

bar(&a);  // does set a.x to 0


note: all fields of a struct are copied, even array fields

struct vector {
    double vals[3];
};
    // indistinguishable from an array of 3 doubles in memory


the size of a struct is at least the sum of the sizes of its fields
the alignment of a struct is the maximum alignment of its fields


union
-----

the dual of struct
    instead of having all the elements at once,
    a union has one at a time
    
union fori {
    float f;
    int i;
};

union fori x;   // x may contain a float or an int

x.f = 2.5;

note: it is incorrect to use the wrong accessor to read the union
    it is impossible to detect which type of value is present
    
we can use this to combine mutually exclusive variables or struct fields
    to avoid using too much memory
    --> usually unnecessary
    
the size of a union is the size of its largest variant






typedef
-------

gives a new name to an existing type

typedef [existing type] [new name];

typedef int age;
    // declares a type "age", which is an int
    
typedef struct point point_t;
    // declares a type "point_t", which is struct point

    
typedef double vector[3];
    // declares a type "vector" which is an array of 3 doubles
    
    vector v = { 0, 3.5, -9.0 };
    

typedef int (*comparison_fun)(void *, void *);
    // declares a type "comparison_fun", which is a pointer to
    // a function returning int and taking void *, void *
    
    
    we could use this to simplify the signatures for our sorting functions
    
    void sort(void *a, size_t nelems, size_t elemlen, comparison_fun compare)
    {
        ...
    }
    



common use:

typedef struct {
    double x;
    double y;
} point;
    // creates a type "point" which is a struct with two doubles x and y


more on structs
---------------

note: structs directly contain their fields, so recursive structures
    must use pointers
    
struct node {
    data_t data;
    struct node next;   // direct recursion is not allowed
};
    // sizeof(struct node) >= sizeof(data_t) + sizeof(struct node)
    // as defined, struct node cannot have any finite size

struct node {
    data_t data;
    struct node *next;
};


typedef struct {
    data_t data;
    node_t *next;
} node_t;
    // unfortunately, node_t doesn't exist until after the typedef
    // so our struct declaration is invalid


typedef struct node {
    data_t data;
    struct node *next;
} node_t;
    // works, and gives us a convenient name



like variables and array accessors, struct fields are "l-values"

    -> we can assign to them
    -> we can get pointers to them


p.x = 5;
q->x = 6;


&p.x  // address of field within struct

&q->x

we can combine structs and arrays

point_t ps[10];  // array of 10 points

ps[3].x = 34;

struct polygon P = ...;

P.vertices[4].x

P             : struct polygon
P.vertices    : struct point *
P.vertices[4] : struct point



P.vertices[0].x
P.vertices->x    // same as above, but confusing to write


node_t *head = ...;

head->next->next->data




Headers & Preprocessor
----------------------

C is actually two languages

    "real" C and CPP, the language of the C preprocessor
    
    C preprocessor is a stage that runs before compilation that
        transforms our source code


lines beginning with # are directives to the preprocessor

#include "some_file"
    <- inserts the contents of some_file into this one
    
#include <some_file>
    <- inserts the contents of some_file into this one

    using "" implies a relative path, starting from this source file's location
    
    using <> tells the preprocessor to look in the INCLUDE directories
        e.g., /usr/include
        
        
    use "" for project-specific files
    use <> for standard/installed libraries
    

most commonly used to include "header" files

    -> normally end in .h
    -> C code containing declarations
        types, function prototypes, global variable declarations
        
#include <stdio.h>

having these prototypes allows the compiler to write code calling these
functions


** EXAMPLE posted to Canvas under Files->Source Code->arraylist
