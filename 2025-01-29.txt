CS 214 / Objects and pointers
=============================

My office hours: Monday/Friday, 2:00 - 4:00 PM, Hill 448

Recitation will begin next week

recap
-----

an object is a region of memory that stores data
    -> to be used, we must know where it is and what sort of data it stores

each variable in C is associated with an object
    "direct" reference

three kinds of objects: static, stack, and heap
    distinguished by lifetime
    static and stack are managed by language
    heap is managed by programmer

arrays
------

array variables directly refer to array objects

array objects are contiguous sequences of smaller objects (elements)


int a[20];   // declares an array of 20 integers, named "a"


array objects contain no metadata -- only the values of their elements
given an array, we cannot learn its size or type
    we must remember array lengths, or provide them ourselves

array accesses are not bounds checked

    a[i]   <- directly refers to element i of array a
        <- indexes start at 0
        

double m[5][5];
    array of 5 arrays, each an array of 5 doubles

    m[i][j]   <- directly refers to element j of array i of m
        <- that is, element i,j of matrix m
        
    m[i]  <- directly refers to row i of m (an array)


like other variables, array variables are not implicitly initialized

special initializer syntax

    double m[3] = { 0, 1, 4.5 };

if we are initializing the entire array, we can omit the dimension

    double m[] = { 0, 1, 4.5 };
    
we can also partially initialize an array

    double m[25] = { 1, 2, 3 };
    
    m has length 25, but only the first 3 values are initialized
    
    in traditional C, the remaining 22 elements are uninitialized
    the 2011 C standard says they are initialized to 0

we can also initialize multi-dimensional arrays

    double m[2][2] = { { 1, 2 }, { 3, 4 } };
    
    double m[2][2] = { 1, 2, 3, 4 };
        // traditional, but disfavored
        // this was allowed because multi-dimensional arrays are
        // indistinguishable from one-dimensional arrays
        
we can pass arrays to functions
    when we do so, our code becomes generic over array length
    array lengths must be agreed upon or else provided explicitly

    int sum(int a[], int n)
    {
        int total = 0;

        for (int i = 0; i < n; i++) {
            total += a[i];
        }
        
        return total;
    }

note: arrays are passed by reference, not by value

    void clear(int a[], int n)
    {
        for (int i = 0; i < n; i++) {
            a[i] = 0;
        }
    }

...

    int b[4];
    clear(b, 4);
        // at this point, b contains all zeros


strings
-------

C does not have a string type

but, by convention a string is a sequence of characters that ends with
    a special terminator character
    
we can store strings in character arrays

    char w[5] = { 'a', 'b', 'c', 'd', '\0' };
    
        w is an array of 5 chars
        w contains a string of 4 chars + a terminator
        
    '\0' is the terminator
        the meaning is just "character with integer value 0"
        
    don't confuse '\0' with '0'
    '\0' == 0

the terminator allows us to store strings of different lengths in the same
    array

string literals  - text enclosed by double quotes

    "foo"   <- string literal
            <- C automatically inserts the terminator
            
            
a string literal is usually a reference to an array in the static area
-> these should be treated as read-only

exception: using string literals to initialize char arrays

    char w[5] = "abcd";
        <- equivalent to what I wrote above, but clearer

    char w[] = "abcd";
        <- also equivalent

    char name[255] = "Default";



    char w[] = "abcd";
        // contents of w: 'a', 'b', 'c', 'd', '\0'
    
        strlen(w) == 4
        sizeof(w) == 5
    
    w[1] = '\0';
        // contents of w: 'a', '\0', 'c', 'd', '\0'
        
        strlen(w) == 1
    

popular string functions ( use #include <string.h> )
    strlen()  - length of string (excluding terminator)
    strcpy()  - copies a string from one char array to another
        strcpy(dest, source)
        
        strcpy(w, "def");
            note: be certain that the destination is large enough!
    
    strcmp() - given 2 strings, says which is earlier
        returns an int
            0 if equal
            negative if first string is earlier
            positive if first string is later
            
        strcmp() uses lexicographic ordering


pointers
--------


recall: all data is stored in objects; all objects have locations

    a pointer represents a location (or address)
    
we can use pointers to indirectly reference objects
    -> only way to refer to heap objects
    

we can store pointers in pointer variables

    int *p;     <- p will contain the address of an int object
    
        p's value tells us where an object is located
        p's type tells us what sort of data is in that object
        
    int x;
    int *p;
    p = &x;    <- & "address of"; obtains address of variable's object
    
    
    x = 5;
    *p = 5;
    
        unary * "dereferences" a pointer
        
        
            p by itself means an address
            *p means an integer at that address
            
string literals are actually pointers!
when we pass arrays to functions, we are passing pointers


    int *p;
    
    p  <-  pointer, address of an int somewhere
    *p <- the int indicated by p
    &p <- pointer to p, address of an int *
    
    int **q;
    q = &p;
    p = &x;
    
    now x, *p, **q all refer to the same object
    
    
new ways to refer to arrays

    int a[20];   // automatically creates an array
    int *p;      // does not create anything (aside from its own object)
    
    p = a;   // here, p and a refer to the same array in memory
    
    
    p[0] is the same as a[0]
    p[i] is the same as a[i]
    
    p = &a[5];
    
    p[0] is the same as a[5]
    p[i] is the same as a[5 + i]
    p[-1] is the same as a[4]
    
pointer arithmetic

    valid whenever a pointer points to part of an array
    
    int a[20];
    int *p = a;   // initialize p to point to a
    
    p  <-  same address as a
    p + 1  <- one integer after p, same address as a[1]
    
    in general: p + i  == &a[i]  == &p[i] == a + i
    
    note: operands of + are different types (pointer and integer)
    
        like regular +, pointer arithmetic works in both orders
        
            1 + p  == p + 1
            
    we can dereference these pointers
        *(p + 1) is the same as p[1]
            also the same as *(1 + p)
            and (weirdly) also the same as 1[p]



heap objects
------------


recall: no variables directly refer to heap objects

we can create heap objects using malloc()

    we give malloc() the size of the object we want to create
    malloc() returns a pointer to that object
    
to ponder:
    how can we know how big an object we need?
    what if there is not enough space for the object?
    
    


