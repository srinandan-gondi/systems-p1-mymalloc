CS 214 / C
==========

Objects
-------

object - A location in memory that we can store data in
    location (where in memory the object is)
        address - every byte in memory has a number
            we use the address of the first byte as the address of an object
    type
        how big the object is
        which operations to use
            e.g., integer vs floating-point arithmetic
    value
        bytes stored in the object
        
note:
    object value is generally only known at run-time
    object type is only known at compile-time
        -> unlike Java, we cannot query the type of an object
    
    location - may be known at compile time (like variables) or not
        (like heap objects)


three kinds of objects (based on lifetime)

    static objects - always exist
        global variables name static objects
        static local variables name static objects
        functions
        string literals
        
    stack objects - tied to a function call
        created when function starts, destroyed when function exits
        local variables
        
    heap objects - explicitly allocated and deallocated
        not named by any variable
        -> we can only refer to them indirectly (by address)
            
--

int counter()
{
    static int n = 0;
    n++;
    
    return n;
}

--

C's type system
    primary function: guide code generation in compiler
    secondary function: detect some errors
    
    
types
    integer types
        can be signed (default) or unsigned
        can be default size, short, or long
        
        int                - signed, default size
        unsigned long int  - unsigned, long size
        short              - signed, short size (int is assumed)
        
        C does not define the actual sizes or the signed representation
        
        size requirements are:
            short is >= 2 bytes
            long is >= 4 bytes
            long > short
            short <= int <= long
            
        on modern hardware, typically:
            short = 2 bytes
            int = 4 bytes
            long = 8 bytes
            
        char, unsigned char = 1 byte
            character literals are automatically translated to integers
            by the compiler
                'A' == 65
                
            character encoding is almost always ASCII (or some superset)

floating-point
    float and double
        C does not mandate a particular representation
        but IEEE is usually the only choice

    in practice: float = 4 bytes, double = 8 bytes
        most floating-point math uses double internally
        
promotion and casting

    double x = 2.5;
    
    x = x + 1;
        the use of x here forces floating-point arithmetic
        1 is automatically promoted to double
        
    operators like + require both operands to be the same type
        if we write code that uses mixed-type operands, C says that
        one value will be promoted so that both values have the same type
        
    int n = 3;
    n = n / 1.5;
        this will promote the value of n and use FP division
        the result is truncated to an integer
        result: n = 2
        
    in general,
        shorter int types promote to longer int types
        int types promote to FP types
    
    
in addition to implicit type conversions, we can explicitly convert types
    ("casting")

    double x = 1.5;
    
    x         - double
    (int) x   - int

    (unsinged int) x - unsigned int
    
for both implicit and explicit casts, the compiler will insert code to
convert, truncate, or extend values appropriately


literal values

    writing a number with no decimal point defaults to signed int
    
        456
        literals that are too large will be truncated
    
    put U at the end to force unsigned int
    put L at the end to force long int
    
    most numbers are decimal
    numbers with a leading 0 are octal
    numbers with a leading 0x are hexadecimal
    
    0x12345678    - signed int (written in hex)
    0x12345678ABL - signed long int (written in hex)
    
     long int n = 0x123456789ABL;
    
#include <limits.h>

int x = INT_MAX;  //  largest possible signed integer

x = x + 1;  // undefined!
    // maybe it's INT_MIN, but we can't assume that


if (x < x + 1) {
    // compiler is allowed to assume this is always true
}


Arrays
------

one or more values of a type stored contiguously in memory
    does not include its length
    does not include boundaries
    
    implication: no automatic bounds checking

    why not?
        no extra space for storing size
        no extra time for checking bounds
        -> going out of bounds is always a bug, so time spent checking
            correct code is wasted

array variables are declared with a type and dimension

    int a[10];
    
        array of 10 integers
        dimension must be a constant (or constant expression)
        
        allocation and deallocation code created by compiler
        
array indexing

    a[0]   - refers to first element of a
    a[i]   = refers to element i of a
    
    
    a[10]  - one past the end of the array (declared above)
    a[-1]  - one before the start of the array
